From 18bd59990196462cde8011458e2518118b1b6681 Mon Sep 17 00:00:00 2001
From: Patrick Palka <ppalka@redhat.com>
Date: Tue, 29 Nov 2022 09:55:21 -0500
Subject: [PATCH 530/547] c++: explicit specialization and trailing
 requirements [PR107864]

Here we're crashing when using the explicit specialization of the
function template g with trailing requirements ultimately because
earlier decls_match (called indirectly from register_specialization) for
for the explicit specialization returned false since the template has
trailing requirements whereas the specialization doesn't.

In r12-2230-gddd25bd1a7c8f4, we fixed a similar issue concerning template
requirements instead of trailing requirements.  We could extend that fix
to ignore trailing requirement mismatches for explicit specializations
as well, but it seems cleaner to just propagate constraints from the
specialized template to the specialization when declaring an explicit
specialization so that decls_match will naturally return true in this
case.  And it looks like determine_specialization already does this,
albeit inconsistently (only when specializing a non-template member
function of a class template as in cpp2a/concepts-explicit-spec4.C).

So this patch makes determine_specialization consistently propagate
constraints from the specialized template to the specialization, which
in turn lets us get rid of the function_requirements_equivalent_p special
case added by r12-2230.

	PR c++/107864

gcc/cp/ChangeLog:

	* decl.cc (function_requirements_equivalent_p): Don't check
	DECL_TEMPLATE_SPECIALIZATION.
	* pt.cc (determine_specialization): Propagate constraints when
	specializing a function template too.  Simplify by using
	add_outermost_template_args.

gcc/testsuite/ChangeLog:

	* g++.dg/concepts/explicit-spec1a.C: New test.

(cherry picked from commit 36cabc257dfb7dd4f7625896891f6c5b195a0241)
---
 gcc/cp/decl.cc                                |  4 +---
 gcc/cp/pt.cc                                  | 19 ++++++++-----------
 .../g++.dg/concepts/explicit-spec1a.C         | 11 +++++++++++
 3 files changed, 20 insertions(+), 14 deletions(-)
 create mode 100644 gcc/testsuite/g++.dg/concepts/explicit-spec1a.C

diff --git a/gcc/cp/decl.cc b/gcc/cp/decl.cc
index fd1a1cbbf2c..012eac5096d 100644
--- a/gcc/cp/decl.cc
+++ b/gcc/cp/decl.cc
@@ -954,9 +954,7 @@ static bool
 function_requirements_equivalent_p (tree newfn, tree oldfn)
 {
   /* In the concepts TS, the combined constraints are compared.  */
-  if (cxx_dialect < cxx20
-      && (DECL_TEMPLATE_SPECIALIZATION (newfn)
-	  <= DECL_TEMPLATE_SPECIALIZATION (oldfn)))
+  if (cxx_dialect < cxx20)
     {
       tree ci1 = get_constraints (oldfn);
       tree ci2 = get_constraints (newfn);
diff --git a/gcc/cp/pt.cc b/gcc/cp/pt.cc
index 19dd181c62a..4e9f587f581 100644
--- a/gcc/cp/pt.cc
+++ b/gcc/cp/pt.cc
@@ -2528,17 +2528,14 @@ determine_specialization (tree template_id,
     }
 
   /* It was a specialization of a template.  */
-  targs = DECL_TI_ARGS (DECL_TEMPLATE_RESULT (TREE_VALUE (templates)));
-  if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (targs))
-    {
-      *targs_out = copy_node (targs);
-      SET_TMPL_ARGS_LEVEL (*targs_out,
-			   TMPL_ARGS_DEPTH (*targs_out),
-			   TREE_PURPOSE (templates));
-    }
-  else
-    *targs_out = TREE_PURPOSE (templates);
-  return TREE_VALUE (templates);
+  tree tmpl = TREE_VALUE (templates);
+  *targs_out = add_outermost_template_args (tmpl, TREE_PURPOSE (templates));
+
+  /* Propagate the template's constraints to the declaration.  */
+  if (tsk != tsk_template)
+    set_constraints (decl, get_constraints (tmpl));
+
+  return tmpl;
 }
 
 /* Returns a chain of parameter types, exactly like the SPEC_TYPES,
diff --git a/gcc/testsuite/g++.dg/concepts/explicit-spec1a.C b/gcc/testsuite/g++.dg/concepts/explicit-spec1a.C
new file mode 100644
index 00000000000..ec678740cb8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/concepts/explicit-spec1a.C
@@ -0,0 +1,11 @@
+// A version of explicit-spec1.C where the template g has trailing instead of
+// template requirements.
+// PR c++/107864
+// { dg-do compile { target concepts } }
+
+template<typename T> concept C = __is_class(T);
+struct Y { int n; } y;
+template<class T> void g(T) requires C<T> { }
+int called;
+template<> void g(Y) { called = 3; }
+int main() { g(y); }
-- 
2.25.1

