From ebb1f6d14c2fef2e4e4aab30525279524c8f9145 Mon Sep 17 00:00:00 2001
From: Jonathan Wakely <jwakely@redhat.com>
Date: Wed, 4 Jan 2023 16:43:51 +0000
Subject: [PATCH 332/547] libstdc++: Fix std::chrono::hh_mm_ss with unsigned
 rep [PR108265]

libstdc++-v3/ChangeLog:

	PR libstdc++/108265
	* include/std/chrono (hh_mm_ss): Do not use chrono::abs if
	duration rep is unsigned. Remove incorrect noexcept-specifier.
	* testsuite/std/time/hh_mm_ss/1.cc: Check unsigned rep. Check
	floating-point representations. Check default construction.

(cherry picked from commit e36e57b032b2d70eaa1294d5921e4fd8ce12a74d)
---
 libstdc++-v3/include/std/chrono               | 38 ++++++++-----
 libstdc++-v3/testsuite/std/time/hh_mm_ss/1.cc | 54 ++++++++++++++++++-
 2 files changed, 79 insertions(+), 13 deletions(-)

diff --git a/libstdc++-v3/include/std/chrono b/libstdc++-v3/include/std/chrono
index 3732a40962a..83e0e5b8bd0 100644
--- a/libstdc++-v3/include/std/chrono
+++ b/libstdc++-v3/include/std/chrono
@@ -1945,6 +1945,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  return __width;
 	}
 
+	constexpr
+	hh_mm_ss(_Duration __d, bool __is_neg)
+	: _M_is_neg(__is_neg),
+	  _M_h (duration_cast<chrono::hours>(__d)),
+	  _M_m (duration_cast<chrono::minutes>(__d - hours())),
+	  _M_s (duration_cast<chrono::seconds>(__d - hours() - minutes()))
+	{
+	  auto __ss = __d - hours() - minutes() - seconds();
+	  if constexpr (treat_as_floating_point_v<typename precision::rep>)
+	    _M_ss = __ss;
+	  else
+	    _M_ss = duration_cast<precision>(__ss);
+	}
+
+	static constexpr _Duration
+	_S_abs(_Duration __d)
+	{
+	  if constexpr (numeric_limits<typename _Duration::rep>::is_signed)
+	    return chrono::abs(__d);
+	  else
+	    return __d;
+	}
+
       public:
 	static constexpr unsigned fractional_width = {_S_fractional_width()};
 
@@ -1959,18 +1982,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	{ }
 
 	constexpr explicit
-	hh_mm_ss(_Duration __d) noexcept
-	: _M_is_neg (__d < _Duration::zero()),
-	  _M_h (duration_cast<chrono::hours>(abs(__d))),
-	  _M_m (duration_cast<chrono::minutes>(abs(__d) - hours())),
-	  _M_s (duration_cast<chrono::seconds>(abs(__d) - hours() - minutes()))
-	{
-	  if constexpr (treat_as_floating_point_v<typename precision::rep>)
-	    _M_ss = abs(__d) - hours() - minutes() - seconds();
-	  else
-	    _M_ss = duration_cast<precision>(abs(__d) - hours()
-					     - minutes() - seconds());
-	}
+	hh_mm_ss(_Duration __d)
+	: hh_mm_ss(_S_abs(__d), __d < _Duration::zero())
+	{ }
 
 	constexpr bool
 	is_negative() const noexcept
diff --git a/libstdc++-v3/testsuite/std/time/hh_mm_ss/1.cc b/libstdc++-v3/testsuite/std/time/hh_mm_ss/1.cc
index 31dd1b2a8f3..24ac80d3c81 100644
--- a/libstdc++-v3/testsuite/std/time/hh_mm_ss/1.cc
+++ b/libstdc++-v3/testsuite/std/time/hh_mm_ss/1.cc
@@ -59,5 +59,57 @@ constexpr_hh_mm_ss()
 
   static_assert(seconds{hh_mm_ss{100min}} == 100min);
 
-  // TODO: treat_as_floating_point_v
+  // treat_as_floating_point_v
+  using fseconds = duration<double, ratio<1>>;
+  constexpr hh_mm_ss<fseconds> fsec{0x123.0004p5s};
+  static_assert(std::is_same_v<hh_mm_ss<fseconds>::precision, fseconds>);
+  static_assert(fsec.hours() == 2h);
+  static_assert(fsec.minutes() == 35min);
+  static_assert(fsec.seconds() == 12s);
+  static_assert(fsec.subseconds() == 0x.0004p5s);
+  static_assert(!fsec.is_negative());
+  static_assert(fsec.to_duration() == 0x123.0004p5s);
+
+  using fminutes = duration<double, ratio<60>>;
+  constexpr hh_mm_ss<fminutes> fmin{-0x1.23p4min};
+  static_assert(std::is_same_v<hh_mm_ss<fminutes>::precision, fseconds>);
+  static_assert(fmin.hours() == 0h);
+  static_assert(fmin.minutes() == 18min);
+  static_assert(fmin.seconds() == 11s);
+  static_assert(fmin.subseconds() == 0.25s);
+  static_assert(fmin.is_negative());
+  static_assert(fmin.to_duration() == -0x1.23p4min);
+}
+
+constexpr void
+default_construction()
+{
+  using namespace std::chrono;
+
+  constexpr hh_mm_ss<seconds> s1;
+  static_assert(s1.to_duration() == s1.to_duration().zero());
+  constexpr hh_mm_ss<duration<char>> s2;
+  static_assert(s2.to_duration() == s2.to_duration().zero());
+  constexpr hh_mm_ss<duration<int, std::centi>> s3;
+  static_assert(s3.to_duration() == s3.to_duration().zero());
+  constexpr hh_mm_ss<duration<long long, std::femto>> s4;
+  static_assert(s4.to_duration() == s4.to_duration().zero());
+  constexpr hh_mm_ss<duration<double>> s5;
+  static_assert(s5.to_duration() == s5.to_duration().zero());
+}
+
+constexpr void
+unsigned_rep()
+{
+  using namespace std::chrono;
+
+  constexpr duration<unsigned, std::milli> ms(3690001);
+
+  constexpr hh_mm_ss hms(ms); // PR libstdc++/108265
+  static_assert( ! hms.is_negative() );
+  static_assert( hms.to_duration() == milliseconds(ms.count()) );
+  static_assert( hms.hours() == 1h );
+  static_assert( hms.minutes() == 1min );
+  static_assert( hms.seconds() == 30s );
+  static_assert( hms.subseconds() == 1ms );
 }
-- 
2.25.1

