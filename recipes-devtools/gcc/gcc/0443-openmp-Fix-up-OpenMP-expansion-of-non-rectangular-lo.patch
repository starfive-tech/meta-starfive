From 629907bff87e238d45afe609716880e8acf9e541 Mon Sep 17 00:00:00 2001
From: Jakub Jelinek <jakub@redhat.com>
Date: Thu, 19 Jan 2023 21:00:08 +0100
Subject: [PATCH 443/547] openmp: Fix up OpenMP expansion of non-rectangular
 loops [PR108459]

expand_omp_for_init_counts was using for the case where collapse(2)
inner loop has init expression dependent on non-constant multiple of
the outer iterator and the condition upper bound expression doesn't
depend on the outer iterator fold_unary (NEGATE_EXPR, ...).  This
will just return NULL if it can't be folded, we need fold_build1
instead.

2023-01-19  Jakub Jelinek  <jakub@redhat.com>

	PR middle-end/108459
	* omp-expand.cc (expand_omp_for_init_counts): Use fold_build1 rather
	than fold_unary for NEGATE_EXPR.

	* testsuite/libgomp.c/pr108459.c: New test.

(cherry picked from commit 46644ec99cb355845b23bb1d02775c057ed8ee88)
---
 gcc/omp-expand.cc                      |  4 +--
 libgomp/testsuite/libgomp.c/pr108459.c | 41 ++++++++++++++++++++++++++
 2 files changed, 43 insertions(+), 2 deletions(-)
 create mode 100644 libgomp/testsuite/libgomp.c/pr108459.c

diff --git a/gcc/omp-expand.cc b/gcc/omp-expand.cc
index bb019ea3a18..6b3ebc221c3 100644
--- a/gcc/omp-expand.cc
+++ b/gcc/omp-expand.cc
@@ -2003,8 +2003,8 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,
 	    t = fold_build2 (MINUS_EXPR, itype, unshare_expr (fd->loops[i].m2),
 			     unshare_expr (fd->loops[i].m1));
 	  else if (fd->loops[i].m1)
-	    t = fold_unary (NEGATE_EXPR, itype,
-			    unshare_expr (fd->loops[i].m1));
+	    t = fold_build1 (NEGATE_EXPR, itype,
+			     unshare_expr (fd->loops[i].m1));
 	  else
 	    t = unshare_expr (fd->loops[i].m2);
 	  tree m2minusm1
diff --git a/libgomp/testsuite/libgomp.c/pr108459.c b/libgomp/testsuite/libgomp.c/pr108459.c
new file mode 100644
index 00000000000..87ce981e080
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/pr108459.c
@@ -0,0 +1,41 @@
+/* PR middle-end/108459 */
+
+char a[17][17];
+
+__attribute__((noipa)) void
+foo (int x, int y)
+{
+  #pragma omp for collapse(2)
+  for (int i = 1; i <= 16; i++)
+    for (int j = i * x + y; j <= 16; j++)
+      a[i][j] = 1;
+}
+
+int
+main ()
+{
+  #pragma omp parallel
+  foo (1, 1);
+  for (int i = 0; i <= 16; i++)
+    for (int j = 0; j <= 16; j++)
+      if (i >= 1 && j >= i + 1)
+	{
+	  if (a[i][j] != 1)
+	    __builtin_abort ();
+	  a[i][j] = 0;
+	}
+      else if (a[i][j])
+	__builtin_abort ();
+  #pragma omp parallel
+  foo (2, -2);
+  for (int i = 0; i <= 16; i++)
+    for (int j = 0; j <= 16; j++)
+      if (i >= 1 && j >= 2 * i - 2)
+	{
+	  if (a[i][j] != 1)
+	    __builtin_abort ();
+	}
+      else if (a[i][j])
+	__builtin_abort ();
+  return 0;
+}
-- 
2.25.1

